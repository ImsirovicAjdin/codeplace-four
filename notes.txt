Directory Course from Codeplace, on Rails 5

1
gem install rails
rails -v // 5.02

2
rails new stukplaces // stukplaces/ folder created, 
    how to run rails 5 on c9.io?

3
cd estuk; rails server -b $IP -p $PORT; 
    it's running, how to get to it?
click on 'Share' next to gear in c9 workspace, copy the 2nd link, paste in new tab and run

4
SAVE FIRST COMMIT: 
    git init; git add --all; git commit; (not passing -m will open the nano editor to add the commit message)
    type the commit message
    CTRL O; [ENTER]; CTRL X (save the message; confirm command; exit nano editor)
    
5
ADD REMOTE REPOSITORY:
    In github, click new repository, give it a good name and description, then:
    git remote add origin https://github.com/ImsirovicAjdin/codeplace-four.git
    git push -u origin master
    
####################

13
INSTALLING BOOTSTRAP

Step 1
We will be using our favourite Front-End framework of choice, bootstrap!

Head over to the seyhunak/twitter-bootstrap-rails gem documentation on Github, and take a short look at the instructions. When you're done, we'll add the gem to our gemfile and run the bundle install command. 
https://github.com/seyhunak/twitter-bootstrap-rails

./gemfile.rb
gem 'twitter-bootstrap-rails', :git => 'git://github.com/seyhunak/twitter-bootstrap-rails.git'

 we could also just use 'bundle' to substitute 'bundle install'

Step 2
As noticed in the documentation, we need to run a generator for us to install bootstrap. We want to specify the use of static files for our app.

rails g bootstrap:install static

Step 3
Save our work, commit it to Github.

git commit -m "Install bootstrap"

###########
14 
INSTALL FONTAWESOME

Step 1
To add some more awesome styling power in our application, we are going to use Icons. 
And one of the best assets out there is 'font-awesome'. 

Check out the documentation for the bokmann/font-awesome-rails gem, and if you did, add it to the gemfile and run bundle. 
https://github.com/bokmann/font-awesome-rails

Step 2
Open the gemfile, and add the gem to the bottom.

bundle

Step 3
And the best part is, that we only have to add one line to the applications.css assets pipeline in order for the font-awesome to work! 
./app/assets/stylesheets/application.css
<<EOF
 *
 *= require_tree .
 *= require font-awesome
 *= require_self
 */
 
Step 4
Save our work, and push it up to Github. 
git commit -m "Added Font-Awesome"


###########
15
INSTALL SIMPLE FORM

Step 1
Great apps have great forms! Lucky for us, there is an awesome gem from the hero's of Plataformatec that have simplified our life and standardizing a lot of work for us. 
Go to the plataformatec/simple_form documentation, and when you're done, add it to the bottom of the gemfile and run bundle. 
https://github.com/plataformatec/simple_form

./gemfile.rb
gem 'simple_form'

bundle

Step 2
We have read the documentation, so we know we have to run the simple_form generator, and specify the use of bootstrap.

rails g simple_form:install --bootstrap

Step 3
And save our work, commit it to Github.

git commit -m "Installed Simple Form"

###########
16
GENERATING THE HOME PAGE

Step 1
Every application needs a landing page right?
In my workflow I like to use a separate controller for all the static pages, like the home / contact / info kind of pages.  
Open the terminal, and run rails generate controller Pages home .This will create the PagesController with the :home action in it, and even open up a route for it.

rails g controller Pages home

 you can substitute rails generate, with rails g

Step 2
Let's set this new page as the root of our application, so that we can have our landing page. 
Open the routes.rb file, and substitute the     line   with: 
root 'pages#home' 
./app/config/routes.rb
<<BOF
Rails.application.routes.draw do
    
 # MAKE SURE TO REMOVE THE GET LINE
  get 'pages/home'
  root 'pages#home'        
  
  # The priority is based upon order of creation: first created -> highest priority.
  # See how all your routes lay out with "rake routes".
  ...
  
  
  
Step 3
Go to your console, start a new rails server, and inspect your localhost:3000/
rails s 

Step 4
And as usual, commit the work to Github.

git commit -m "Add PageController and landing page"


###########
17
CREATING A HEADER

Step 1
let's move on and create Navbar, we'll use the bootstrap navbar for this. 
But first, let's create a new _header.html.erb partial in our app/views/layouts/ folder. 
touch ./app/views/layouts/_header.html.erb

And render our new _header partial in the layouts/application.html.erb.
./app/views/layouts/application.html.erb
<<EOF
        <body>
        
        	<%= render 'layouts/header' %>
        
        	<%= yield %>
        
        </body>
        </html>

Step 2
In your browser, navigate to getbootstrap.com, and copy-paste the entire navbar elements, to your new _header partial. 
./app/views/layouts/_header.html.erb
        <nav class="navbar navbar-default">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="#">StukPlaces</a>
            </div>
        
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
              <ul class="nav navbar-nav">
                <li class="active"><a href="#">Places<span class="sr-only">(current)</span></a></li>
                
                
              </ul>
              <form class="navbar-form navbar-left" role="search">
                <div class="form-group">
                  <input type="text" class="form-control" placeholder="Search">
                </div>
                <button type="submit" class="btn btn-default">Submit</button>
              </form>
              <ul class="nav navbar-nav navbar-right">
                <li><a href="#">Link</a></li>
                
              </ul>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>

Step 5
Now would be a good moment to refresh your browser!
And if all went well, nothing changed!
But we should make two minor adjustments, first the Brand link should be replaced with the link to the root_path, and on the right side of the navbar, there should be two links: login and signup. 
-
      <a class="navbar-brand" href="#">StukPlaces</a>
+
      <%= link_to "StukPlaces", root_path, class: 'navbar-brand' %>
-
        <li><a href="#">Link</a></li>
+
        <li><a href="#">login</a></li>
        <li><a href="#">signup</a></li>

Step 6
After you inspected your browser again, it's time to commit and save our work.

git commit -m "Add the Header"



###########
18
INSTALLING DEVISE

Step 1
The next step in making our application is adding Users. 
For this, we'll be using the awesome gem from plataformatec/devise, so head over to the repo and read up on the documentation, and then continue by adding it to the gemfile and run bundle. 
https://github.com/plataformatec/devise

gem 'devise'

bundle

Step 2
Devise requires us to run the devise generator for installation.

rails g devise:install

And since we will be updating the User and the user views, we'll generate the views to.

rails g devise:views

Step 3
Now it's time to create the User model,

rails g devise User

Inspect the created migration, and then migrate it to the database.

rake db:migrate

Step 4
We want our Users to have a :name field, unfortunately, devise didn't provide us with a User model that has the :name field. But, luckily, we can easily create this ourselves. 
Let's create a migation to Add the Name to Users, the name field should be of the string type.

rails g migration AddNameToUsers name:string

And after inspecting the migration, we can migrate it to the database. 

rake db:migrate

Step 5
The next thing we want to do is make sure the User will have a name when a user is created. We'll make a validation for that, in the User.rb model. 
./app/models/user.rb
        class User < ActiveRecord::Base
          # Include default devise modules. Others available are:
          # :confirmable, :lockable, :timeoutable and :omniauthable
          devise :database_authenticatable, :registerable,
                 :recoverable, :rememberable, :trackable, :validatable
        
           validates_presence_of :name      
        end
        
Step 6
Now that we have created the field for the User model, we have to update the UsersController. The way to do this with devise, is to create a new Controller for this. 
Inside the app/controllers/ folder create a new controller called registrations_controller.rb. 
You could use either your editor and right-click on the folder, select: 'new file',  or use the terminal command from inside the app directory: 'touch  app/controller/registrations_controller.rb' 

touch ./app/controllers/registrations_controller.rb

According to the documentation, this should be inheriting from the Devise::RegistrationsController. 

./app/controllers/registrations_controller.rb

        class RegistrationsController < Devise::RegistrationsController
        
        end

According to the documentation, we need to create the sign_up and account_update params, in order for rails to pass through the save params. In these params we specify the permitted and required parameters for the user.
The only difference between the two, is that the account_update_params also take a :current_password field, the rest is pretty much self explaining.  

./app/controllers/registrations_controller.rb

        class RegistrationsController < Devise::RegistrationsController
        	
        	def sign_up_params
        		params.require(:user).permit(:name, :email, :password)
        	end
        
        	def account_update_params
        		params.require(:user).permit(:name, :email, :password, :current_password)
        	end
        
        end

Step 7
Now we need to tell Devise to use this registrations controller, instead of the default. 
Again, all this can be found in the documentation of Devise. 
Open the routes.rb and specify devise to use the new controller. 

./app/config/routes.rb
<<BOF
Rails.application.routes.draw do
  devise_for :users, controllers: { registrations: 'registrations'}
  root 'pages#home'
  
Step 8
And with our new fields and controller set, we can update the views. 
First we start with the app/views/devise/registrations/new.html.erb 
We want to remove the password_confirmation field, and add the input field for :name. 
Also we want that field to be autofocused instead of the :email field.
./app/views/devise/registrations/new.html.erb
<h2>Sign up</h2>

<%= simple_form_for(resource, as: resource_name, url: registration_path(resource_name)) do |f| %>
  <%= f.error_notification %>

  <div class="form-inputs">
    <%= f.input :name, required: true, autofocus: true %>
    <%= f.input :email, required: true %>

    <%= f.input :password, required: true, hint: ("#{@minimum_password_length} characters minimum" if @minimum_password_length) %>
  </div>

  <div class="form-actions">
    <%= f.button :submit, "Sign up" %>
  </div>
<% end %>

<%= render "devise/shared/links" %>

Basically the same goes for the ../registrations/edit.html.erb view,
Add the :name field, give it the autofocus. Remove the autofocus from the email field, and remove the password_confirmation field. 
./app/views/devise/registrations/edit.html.erb
<h2>Edit <%= resource_name.to_s.humanize %></h2>

<%= simple_form_for(resource, as: resource_name, url: registration_path(resource_name), html: { method: :put }) do |f| %>
  <%= f.error_notification %>

  <div class="form-inputs">
    <%= f.input :name, required: true, autofocus: true %>
    <%= f.input :email, required: true %>
    
    <% if devise_mapping.confirmable? && resource.pending_reconfirmation? %>
      <p>Currently waiting confirmation for: <%= resource.unconfirmed_email %></p>
    <% end %>

    <%= f.input :password, autocomplete: "off", hint: "leave it blank if you don't want to change it", required: false %>

    <%= f.input :current_password, hint: "we need your current password to confirm your changes", required: true %>
  </div>

  <div class="form-actions">
    <%= f.button :submit, "Update" %>
  </div>
<% end %>

<h3>Cancel my account</h3>

<p>Unhappy? <%= link_to "Cancel my account", registration_path(resource_name), data: { confirm: "Are you sure?" }, method: :delete %></p>

<%= link_to "Back", :back %>

Step 9
Before we continue and create our first user, let's save our work!
Doing a lot of small commits is actually considered as good practice, so save the work and commit it to Github.

git commit -m "Update user Registration and New views"

###########
19
ADDING FLASH MESSAGES
Before we try out our sign_up and edit form, we should add 'flash messages'. These kind of notifications are important to signal the user if an event was successful or failed, and maybe provide some kind of hint in case of a failure. 

Step 1
Bootstrap comes with great flash messages right out of the box, and it even has a nice javascript function to close the flash message. 
Let's use the standard Bootstrap flash-message and the by Rails provided Flash object.
Since these messages can occur throughout the entire application we'll add them to the application.hml.erb view, since that's the master view page. 
We'll use the bootstrap alert class, and give it the standard blue info color, and a nice fade-in. Also we add a button to dismiss the message. Since the standard flash object contains both the type and the message we'll have to specify them in the opening block, but we'll only use the message for this course. 
Place it right above the <%= yield %> statement, and right under the header. 

./app/views/layouts/application.html.erb
...
	<%= render 'layouts/header' %>
	
	<% flash.each do |type, message|  %>
		<div class="alert alert-info fade-in">
			<button class="close" data-dismiss="alert">x</button>
			<%= message %>
		</div>
	<% end %>

	<%= yield %>
...

Step 2
Now that we have the Application.html.erb view open, we should also add a container around the yield, so everything looks just a bit nicer. 

./app/views/layouts/application.html.erb
<!DOCTYPE html>
<html>
<head>
  <title>Stukplaces</title>
  <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track' => true %>
  <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %>
  <%= csrf_meta_tags %>
</head>
<body>
	
	<%= render 'layouts/header' %>

	<% flash.each do |type, message|  %>
		<div class="alert alert-info fade-in">
			<button class="close" data-dismiss="alert">x</button>
			<%= message %>
		</div>
	<% end %>

	<div class="container">
		<%= yield %>
	</div>

</body>
</html>

Step 3
And we should also update the login and logout links in our header, of course only showing the login and signup if there is not a current_user. 
Open your _header.html.erb partial, and add the links to login, logout, signin or signout.
Don't forget to remove the old links, and to add the method: :delete to the signout path.

./app/views/layouts/_header.html.erb

+
        <% if current_user %>
          <li><%= link_to 'Settings', edit_user_registration_path %> </li>          
          <li><%= link_to 'Logout', destroy_user_session_path, method: :delete %></li>
        <% else %>
          <li><%= link_to 'Login', new_user_session_path %></li>
          <li><%= link_to 'Signup', new_user_registration_path %></li>
        <% end %>

-
        <li><a href="#">login</a></li>
        <li><a href="#">signup</a></li>

You probably know how we got these routes, but it's always good to check your routes in the terminal to make sure.
rake routes

Step 4
As final, let's add a finishing touch to our flash messages by styling them. 
Open the app/assets/stylesheets/pages.scss file, and the following class to style it.
Give the .alert{} class the an absolute position, a z-index of 1, and a fixed width of 200px.

./app/assets/stylesheets/pages.scss

// Place all the styles related to the Pages controller here.
// They will automatically be included in application.css.
// You can use Sass (SCSS) here: http://sass-lang.com/
.alert{
	position: absolute;	
	z-index: 1; 
	width: 200px ; 
}

Step 5
If you didn't do so, this would be a great moment to restart your server, and head over to the localhost:3000/ to test our new layout, and the flash messages! 
Signup for your app, and be sure all your new links and flash messages work. 

Step 6
Time to save our work, and commit it to Github.

git commit -m "Add Flash messages"



###########
20
ADDING GRAVATARS

Step 1
Our users have no profile picture yet, and yet there is very simple way for each user to have a profile image. On the webs, they're called 'gravatar', and if you head over to www.gravatar.com you'll see exactly what I mean. 
There is even a gem for this, so let's add it to our Gemfile!
gem 'gravatarify', '~> 3.0.0'

And run bundle as usual
bundle

Step 2
Let's add the horizontal devider <hr> underneath the button in our app/views/devise/registrations/edit.html.erb form.  
And just below the <hr > we'll add the gravatar_tag helper that comes with the gem, and give the gravatar a size of 100 pix. 
Also add a link for the user to change the avatar, and point it to the gravatar website. 
<<EOF
  <div class="form-actions">
    <%= f.button :submit, "Update" %>
  </div>
  
  <hr>
  <%= gravatar_tag current_user.email, size: 100 %>
  <%= link_to 'change avatar', 'http://en.gravatar.com' %>

<% end %>

<h3>Cancel my account</h3>

<p>Unhappy? <%= link_to "Cancel my account", registration_path(resource_name), data: { confirm: "Are you sure?" }, method: :delete %></p>

<%= link_to "Back", :back %>

Step 3
Start up your server, and go to your user Settings Page to see your Profile image in action!

what if there is no image displayed?
If there is no image displayed, the user needs to sign up for gravatar.
Gravatars are widely used and most users will have them. 

Step 4
Looks good, save our work and commit it to Github.com

git commit -m "Added user Gravatar"

###########
21
GENERATING THE PLACES SCAFFOLD
Before we continue I'd like to point out that normally on intermediate or advanced courses we don't use any scaffolding. But for time-saving purposes we will scaffold the Places.

Step 1
So let's start with Scaffolding the Places.
We want the places to have:
    name:string
    address:string ( for later with the geocoder)
    description: text
    phone:string
    website:string
    user_id:string
And we'll be giving the extra flag to create the migration, without any stylesheets.

rails g scaffold Places name:string address:string description:text phone:string website:string user_id:integer --no-stylesheets
 

And after you have inspected the migration file, you can run the migration.

rake db:migrate

Step 2
Next we want to validate the presence of the Places fields, for the name, phone, address, website and user_id. Open the Places.rb model, and add the validations.

./app/models/places.rb

class Place < ActiveRecord::Base
	validates_presence_of :name 
	validates_presence_of :phone 
	validates_presence_of :address 
	validates_presence_of :website 
	validates_presence_of :user_id 
end

Step 3
We know that the places will be owned by a User, so we might as well continue with adding associations while we have the Places.rb model still open in our text editor.

./app/models/places.rb
class Place < ActiveRecord::Base
	validates_presence_of :name 
	validates_presence_of :phone 
	validates_presence_of :address 
	validates_presence_of :website 
	validates_presence_of :user_id 

	belongs_to :user
end

This also means we need to update the User.rb model, and say, that it has_many :places

./app/models/user.rb
class User < ActiveRecord::Base
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

   validates_presence_of :name      
   has_many :places
end

Step 4
When a user would visit our app now, there won't be a way to reach the places. 
Let's replace the current a:href stub in our _header.html.erb with a proper rails link_to 'places' link, and have it point to the places:index action, to show all the places. 

./app/views/layouts/_header.html.erb
...
      (<ul class="nav navbar-nav">)
-
        <li class="active"><a href="#">Places<span class="sr-only">(current)</span></a></li>
+
        <li><%= link_to 'Places', places_path %></li>
      (</ul>)
...

Step 5
If we now start the server, and go to our localhost:3000, we should have a working places link, and a Page showing all the listings.

This doesn't look very good if you ask me, so open the views/places/index.html.erb and let's make it look better. 
Let's start with removing elements we won't need to be shown on the index view. From the < table head> we remove the user, colspan, and description rows. And let's also remove them from the table body, including the :show :edit :delete actions, because these will be placed in a separate dashboard.

./app/views/places/index.html.erb

-
      <th>Description</th>

      <th>User</th>
      <th colspan="3"></th>

-
        <td><%= place.description %></td>

        <td><%= place.user_id %></td>
        <td><%= link_to 'Show', place %></td>
        <td><%= link_to 'Edit', edit_place_path(place) %></td>
        <td><%= link_to 'Destroy', place, method: :delete, data: { confirm: 'Are you sure?' } %></td>

Step 6
There is a paragraph tag in the top of the view for error notifications, since we now have flash messages we won't be needing this anymore. 
After you have removed the <p id="notice"><%= notice %></p> there are two more things left to do in this view.  
On the bottom, we have a line with a link to creating a new Place record. 
This should only be visible to logged-in users, so let's add these last two updates.      

./app/views/places/index.html.erb
-
<p id="notice"><%= notice %></p>

+
<% if current_user %> 
+
<% end %> 

And finally, add the bootstrap magic to the table, to make it an bootstrap table!

./app/views/places/index.html.erb
<<BOF
<h1>Listing Places</h1>
+
<table class="table">
...

Step 7
When we now start our server and go to the localhost:3000/places view, you'll notice that it looks a lot nicer!

Now some final, adjustments on the app/views/places/_form.html.erb partial to give the fields client side validations to, by stating required: true on those fields. 
./app/views/places/_form.html.erb
<%= simple_form_for(@place) do |f| %>
  <%= f.error_notification %>

  <div class="form-inputs">
+
    <%= f.input :name, required: true %>
    <%= f.input :address, required: true %>
    <%= f.input :phone, required: true %>
old (keep it!, but don't change it)
    <%= f.input :description %>
+
    <%= f.input :website, required: true %>
    <%= f.input :user_id, required: true %>
  </div>

  <div class="form-actions">
    <%= f.button :submit %>
  </div>
<% end %>

And with these updates our Places should look and work nice. Currently, we'll have to assign the :user_id manually, but we'll fix that in the upcoming lectures. 

Step 8
Let's save our work, and push it to Github.
git comit -m "Scaffold Users, and update the views"


###########
22
PLACES NEED A USER
Step 1
I Already mentioned it in the previous chapter, that we will change the way the :user_id is assigned to a place, so let's do that now.
Open the PlacesController.rb, and go to the bottom of the controller. 
Remove the :user_id from the place_params.
./app/controllers/places_controller.rb
<<EOF

    # Never trust parameters from the scary internet, only allow the white list through.
    def place_params
    -
      params.require(:place).permit(:name, :address, :phone, :description, :website, :user_id)
    +
      params.require(:place).permit(:name, :address, :phone, :description, :website )

    end
end

Step 2
Now in the create action, assign the @place variable to be constructed by calling current_user.places.new, like so:

./app/controllers/places_controller.rb

replace:
    @place = Place.new(place_params)
with:
    @place = current_user.places.new(place_params)

Step 3
And to make sure there is a current user, we'll use the :authenticate_user! method from devise, but only on the :new, :edit, :create, :update and :destroy actions.

./app/controllers/pages_conroller.rb
<<BOF
class PlacesController < ApplicationController
+  
  before_action :authenticate_user!, only: [:new, :edit, :create, :update, :destroy ]

Step 4
And finally, we can remove the :user_id field from the app/views/places/_form.html.erb
./app/views/places/_form.html.erb
<<BOF
<%= simple_form_for(@place) do |f| %>
  <%= f.error_notification %>

  <div class="form-inputs">
    <%= f.input :name, required: true %>
    <%= f.input :address, required: true %>
    <%= f.input :description %>
    <%= f.input :phone, required: true %>
    <%= f.input :website, required: true %>
-
    <%= f.input :user_id, required: true %>
  </div>

This should do the trick, restart the server if needed and go to your localhost:3000, and try to create a new place. 

Step 5
Save and commit our work to Github.

git commit -m "Added current user to places"



###########
23
PLACES NEED LOCATION
In this chapter, we'll be adding a map to our places, using google maps. 
For that, we will be needing an api key for google maps.
Maps need special coordinates in order to function, these you may have seen before, are called longitude and latitude.

Step 1
To convert an address to these longitude and latitude coordinates, we will be using a gem provided by alexreisner/geocoder .
When you're done reading the documentation you can add it to the gemfile, and run the bundle command.
https://github.com/alexreisner/geocoder

./Gemfile
<<EOF
gem 'geocoder'

install it
bundle

Step 2
Before we move on, we need to remove all the Places that are stored in the database at this moment. Open up a console, and run Place.delete_all

rails c 
Place.delete_all

Step 3
Next we need to add the latitude and longitude attributes to the Places. So, let's run a migration for this, and have them both be of the float type 

rails g migration AddMapToPlaces latitude:float longitude:float

And after inspection of the migration file, run migrate it to the database.

rake db:migrate

Step 4
Now, according to the documentation, we need to update the Places.rb model.
We need to tell geocoded from which field too 'decode', and to ensure the :geocoded address is validated. 

./app/models/place.rb
class Place < ActiveRecord::Base
	validates_presence_of :name 
	validates_presence_of :phone 
	validates_presence_of :address 
	validates_presence_of :website 
	validates_presence_of :user_id 

	belongs_to :user
+	
	geocoded_by :address 
	after_validation :geocode 
end

Step 5
To test if this works, we need to update our app/views/places/show view, and display the two new fields to the view. 
./app/views/places/show.html.erb
<<EOF
<p>
  <strong>User:</strong>
  <%= @place.user_id %>
</p>
+
    <p>
      <%= @place.longitude %>
      <%= @place.latitude %>
    </p>

<%= link_to 'Edit', edit_place_path(@place) %> |
<%= link_to 'Back', places_path %>

Now restart your server, and head over to your browser. Go to the localhost:3000/places/new, and create a new Place, with your City address.

Step 6
Now, before we can use these Coordinates in the Google Maps Api, we need to get an Api key from the google developers section.  Here is how you get it.
https://developers.google.com/maps/documentation/javascript/get-api-key

Press the [ GET A KEY ] button, and follow the procedure.

And as always,
store the API keys somewhere convenient, so that you can find them later on. 

Step 7
Now, if we follow the Google Developers Guide instructions (https://developers.google.com/maps/documentation/javascript/tutorial), we know that we have to add  our API key in the head section of our page, we can copy the code from the instructions and simply add our own key. 
On a production server you want to configure ENVironment key's, but for now this is just fine. Open your application.html.erb, and add the script snippet from the google documentation.
./app/views/layouts/application.html.erb
<<BOF
<!DOCTYPE html>
<html>
<head>
  <title>Stukplaces</title>
  <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track' => true %>
  <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %>
  <%= csrf_meta_tags %>
     <script async defer
      src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&callback=initMap">
    </script>
...

Make sure, you replace 'YOUR_API_KEY', with your API key.
Step 8
We also need to place the map somewhere, so in the app/views/places/show.html.erb, add a div with the id of 'map-canvas', as per the documentation. Also, specify a style, with the width and height for the map, like so:
./app/views/places/show.html.erb
<<EOF
+
<div id="map-canvas" style="width: 230px; height:230px"></div>

    <%= link_to 'Edit', edit_place_path(@place) %> |
    <%= link_to 'Back', places_path %>

Step 9
Next, we need to place the final part of the javascript, also on the bottom of the places:show page. 

./app/views/places/show.html.erb
<<EOF

<%= link_to 'Edit', edit_place_path(@place) %> |
<%= link_to 'Back', places_path %>
+
    <script type="text/javascript">
      var map;
      function initMap() {
        map = new google.maps.Map(document.getElementById('map-canvas'), {
          center: {lat: -34.397, lng: 150.644},
          zoom: 8
        });
      }
    </script>

Then, we add our coordinates.
./app/views/places/show.html.erb
<<EOF
<script type="text/javascript">
  var map;
  function initMap() {
    map = new google.maps.Map(document.getElementById('map-canvas'), {
    +
      center: {lat: <%= @place.latitude %>, lng: <%= @place.longitude %>},
      zoom: 8
    });
  }
</script>

And if we refresh the browser, you'll see a google map with the place you specified.

But the user has to guess where our address is right now, so let's go back to the documentation and look up how we can add a nice marker.

Step 10
In order to have a marker on our map, we need to remodel our maps script a little bit. 
First, we want to place the coordinates into a separate variable, and replace the center content with this new variable, inside the map object contstructor.

./app/views/places/show.html.erb
<script type="text/javascript">

  var map;
  var myCenter = {lat: <%= @place.latitude %>, lng: <%= @place.longitude %>};
  
  function initMap() {
    map = new google.maps.Map(document.getElementById('map-canvas'), {
      center: myCenter,
      zoom: 13
    });
  }
</script>

Then add the Marker object constructor, and give it the attributes it needs, the position and the map.

./app/views/places/show.html.erb
<script type="text/javascript">

  var map;
  var myCenter = {lat: <%= @place.latitude %>, lng: <%= @place.longitude %>};

  function initMap() {
    map = new google.maps.Map(document.getElementById('map-canvas'), {
      center: myCenter,
      zoom: 13
    });
    var marker = new google.maps.Marker({
      position: myCenter, 
      map: map, 
    });
  }
</script>

And after refreshing the browser (and sometimes restarting the server), we'll see a big fancy marker on our map. Awesome right?!

Step 11
Time to commit our work, and save it to Github!

git commit -m "Add Maps to Places"


###########
24
MAKING PLACES BETTER
Step 1
Before we move on with creating our reviews we should improve the design of our Places show pages, open the app/views/places/show.html.erb and remove the old content.
Just keep the <div >with the map-canvas, and the <script ...</script>, but remove everything else.
./app/views/places/show.html.erb

That includes removing the :edit and :back link, because we'll add them to the dashboard later on.

Step 2
We want our view to be divided into 2 main columns, the left side that will display the Place and its attributes, including the Map. And the second on the right will display the reviews and the review form that we have not created yet, but we can place a stub for now. 
So let's start with adding the bootstrap row, and add two columns, on with the size of 3, and the other with the size of 9, and place a <h3> tag inside each column, with either the Title for that section, or the place.name. 
./app/views/places/show.html.erb
<<BOF
+
 <div class="row">
  <div class="col-md-3">
    <h3><%= @place.name %></h3>
  </div>
  <div class="col-md-9">
    <h3>Reviews by People</h3>
    
  </div>
</div>
old code, don't touch
<div id="map-canvas" style="width: 230px; height:230px"></div>

Step 3
Let's continue by filling in the Place column with the Place attributes, add each attribute of the place inside of a <p> paragraph, and give it a <strong> Title, like so: 
./app/views/places/show.html.erb
<div class="row">
    
  <div class="col-md-3">
    <h3><%= @place.name %></h3>
    <p>
      <strong>Address</strong>
      <%= @place.name %>
    </p>
    <p>
      <strong>Phone</strong>
      <%= @place.phone %>
    </p>
    <p>
      <strong>Website</strong>
      <%= @place.website %>
    </p>
    <p>
      <strong>Description</strong>
      <%= @place.description %>
    </p>
  </div>

Step 4
And last, move the div with the map-canvas id to the bottom of the first column, right below the description paragraph.
./app/views/places/show.html.erb
      <strong>Description</strong>
      <%= @place.description %>
    </p>
    <div id="map-canvas" style="width: 230px; height:230px"></div>  
  </div>
  
Step 5
Check your browser, your show page should now look something like this.
Step 6
If you're happy with your progress, save your work, and Git commit!

git commit -m "Make places better"


###########
25
REVIEWS


###########
26
SCORES

###########
27
AVERAGE

###########
28
DASHBOARD

###########
29
BETTER LANDING PAGE

###########
30
SEARCH

###########
31
FINISHING TOUCHES

###########
32
DEPLOY


