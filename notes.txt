Directory Course from Codeplace, on Rails 5

https://github.com/stukio/stukplaces/

1
gem install rails
rails -v // 5.02

2
rails new stukplaces // stukplaces/ folder created, 
    how to run rails 5 on c9.io?

3
cd estuk; rails server -b $IP -p $PORT; 
    it's running, how to get to it?
click on 'Share' next to gear in c9 workspace, copy the 2nd link, paste in new tab and run

4
SAVE FIRST COMMIT: 
    git init; git add --all; git commit; (not passing -m will open the nano editor to add the commit message)
    type the commit message
    CTRL O; [ENTER]; CTRL X (save the message; confirm command; exit nano editor)
    
5
ADD REMOTE REPOSITORY:
    In github, click new repository, give it a good name and description, then:
    git remote add origin https://github.com/ImsirovicAjdin/codeplace-four.git
    git push -u origin master
    
####################

13
INSTALLING BOOTSTRAP

Step 1
We will be using our favourite Front-End framework of choice, bootstrap!

Head over to the seyhunak/twitter-bootstrap-rails gem documentation on Github, and take a short look at the instructions. When you're done, we'll add the gem to our gemfile and run the bundle install command. 
https://github.com/seyhunak/twitter-bootstrap-rails

./gemfile.rb
gem 'twitter-bootstrap-rails', :git => 'git://github.com/seyhunak/twitter-bootstrap-rails.git'

 we could also just use 'bundle' to substitute 'bundle install'

Step 2
As noticed in the documentation, we need to run a generator for us to install bootstrap. We want to specify the use of static files for our app.

rails g bootstrap:install static

Step 3
Save our work, commit it to Github.

git commit -m "Install bootstrap"

###########
14 
INSTALL FONTAWESOME

Step 1
To add some more awesome styling power in our application, we are going to use Icons. 
And one of the best assets out there is 'font-awesome'. 

Check out the documentation for the bokmann/font-awesome-rails gem, and if you did, add it to the gemfile and run bundle. 
https://github.com/bokmann/font-awesome-rails

Step 2
Open the gemfile, and add the gem to the bottom.

bundle

Step 3
And the best part is, that we only have to add one line to the applications.css assets pipeline in order for the font-awesome to work! 
./app/assets/stylesheets/application.css
<<EOF
 *
 *= require_tree .
 *= require font-awesome
 *= require_self
 */
 
Step 4
Save our work, and push it up to Github. 
git commit -m "Added Font-Awesome"


###########
15
INSTALL SIMPLE FORM

Step 1
Great apps have great forms! Lucky for us, there is an awesome gem from the hero's of Plataformatec that have simplified our life and standardizing a lot of work for us. 
Go to the plataformatec/simple_form documentation, and when you're done, add it to the bottom of the gemfile and run bundle. 
https://github.com/plataformatec/simple_form

./gemfile.rb
gem 'simple_form'

bundle

Step 2
We have read the documentation, so we know we have to run the simple_form generator, and specify the use of bootstrap.

rails g simple_form:install --bootstrap

Step 3
And save our work, commit it to Github.

git commit -m "Installed Simple Form"

###########
16
GENERATING THE HOME PAGE

Step 1
Every application needs a landing page right?
In my workflow I like to use a separate controller for all the static pages, like the home / contact / info kind of pages.  
Open the terminal, and run rails generate controller Pages home .This will create the PagesController with the :home action in it, and even open up a route for it.

rails g controller Pages home

 you can substitute rails generate, with rails g

Step 2
Let's set this new page as the root of our application, so that we can have our landing page. 
Open the routes.rb file, and substitute the     line   with: 
root 'pages#home' 
./app/config/routes.rb
<<BOF
Rails.application.routes.draw do
    
 # MAKE SURE TO REMOVE THE GET LINE
  get 'pages/home'
  root 'pages#home'        
  
  # The priority is based upon order of creation: first created -> highest priority.
  # See how all your routes lay out with "rake routes".
  ...
  
  
  
Step 3
Go to your console, start a new rails server, and inspect your localhost:3000/
rails s 

Step 4
And as usual, commit the work to Github.

git commit -m "Add PageController and landing page"


###########
17
CREATING A HEADER

Step 1
let's move on and create Navbar, we'll use the bootstrap navbar for this. 
But first, let's create a new _header.html.erb partial in our app/views/layouts/ folder. 
touch ./app/views/layouts/_header.html.erb

And render our new _header partial in the layouts/application.html.erb.
./app/views/layouts/application.html.erb
<<EOF
        <body>
        
        	<%= render 'layouts/header' %>
        
        	<%= yield %>
        
        </body>
        </html>

Step 2
In your browser, navigate to getbootstrap.com, and copy-paste the entire navbar elements, to your new _header partial. 
./app/views/layouts/_header.html.erb
        <nav class="navbar navbar-default">
          <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="#">StukPlaces</a>
            </div>
        
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
              <ul class="nav navbar-nav">
                <li class="active"><a href="#">Places<span class="sr-only">(current)</span></a></li>
                
                
              </ul>
              <form class="navbar-form navbar-left" role="search">
                <div class="form-group">
                  <input type="text" class="form-control" placeholder="Search">
                </div>
                <button type="submit" class="btn btn-default">Submit</button>
              </form>
              <ul class="nav navbar-nav navbar-right">
                <li><a href="#">Link</a></li>
                
              </ul>
            </div><!-- /.navbar-collapse -->
          </div><!-- /.container-fluid -->
        </nav>

Step 5
Now would be a good moment to refresh your browser!
And if all went well, nothing changed!
But we should make two minor adjustments, first the Brand link should be replaced with the link to the root_path, and on the right side of the navbar, there should be two links: login and signup. 
-
      <a class="navbar-brand" href="#">StukPlaces</a>
+
      <%= link_to "StukPlaces", root_path, class: 'navbar-brand' %>
-
        <li><a href="#">Link</a></li>
+
        <li><a href="#">login</a></li>
        <li><a href="#">signup</a></li>

Step 6
After you inspected your browser again, it's time to commit and save our work.

git commit -m "Add the Header"



###########
18
INSTALLING DEVISE

Step 1
The next step in making our application is adding Users. 
For this, we'll be using the awesome gem from plataformatec/devise, so head over to the repo and read up on the documentation, and then continue by adding it to the gemfile and run bundle. 
https://github.com/plataformatec/devise

gem 'devise'

bundle

Step 2
Devise requires us to run the devise generator for installation.

rails g devise:install

And since we will be updating the User and the user views, we'll generate the views to.

rails g devise:views

Step 3
Now it's time to create the User model,

rails g devise User

Inspect the created migration, and then migrate it to the database.

rake db:migrate

Step 4
We want our Users to have a :name field, unfortunately, devise didn't provide us with a User model that has the :name field. But, luckily, we can easily create this ourselves. 
Let's create a migation to Add the Name to Users, the name field should be of the string type.

rails g migration AddNameToUsers name:string

And after inspecting the migration, we can migrate it to the database. 

rake db:migrate

Step 5
The next thing we want to do is make sure the User will have a name when a user is created. We'll make a validation for that, in the User.rb model. 
./app/models/user.rb
        class User < ActiveRecord::Base
          # Include default devise modules. Others available are:
          # :confirmable, :lockable, :timeoutable and :omniauthable
          devise :database_authenticatable, :registerable,
                 :recoverable, :rememberable, :trackable, :validatable
        
           validates_presence_of :name      
        end
        
Step 6
Now that we have created the field for the User model, we have to update the UsersController. The way to do this with devise, is to create a new Controller for this. 
Inside the app/controllers/ folder create a new controller called registrations_controller.rb. 
You could use either your editor and right-click on the folder, select: 'new file',  or use the terminal command from inside the app directory: 'touch  app/controller/registrations_controller.rb' 

touch ./app/controllers/registrations_controller.rb

According to the documentation, this should be inheriting from the Devise::RegistrationsController. 

./app/controllers/registrations_controller.rb

        class RegistrationsController < Devise::RegistrationsController
        
        end

According to the documentation, we need to create the sign_up and account_update params, in order for rails to pass through the save params. In these params we specify the permitted and required parameters for the user.
The only difference between the two, is that the account_update_params also take a :current_password field, the rest is pretty much self explaining.  

./app/controllers/registrations_controller.rb

        class RegistrationsController < Devise::RegistrationsController
        	
        	def sign_up_params
        		params.require(:user).permit(:name, :email, :password)
        	end
        
        	def account_update_params
        		params.require(:user).permit(:name, :email, :password, :current_password)
        	end
        
        end

Step 7
Now we need to tell Devise to use this registrations controller, instead of the default. 
Again, all this can be found in the documentation of Devise. 
Open the routes.rb and specify devise to use the new controller. 

./app/config/routes.rb
<<BOF
Rails.application.routes.draw do
  devise_for :users, controllers: { registrations: 'registrations'}
  root 'pages#home'
  
Step 8
And with our new fields and controller set, we can update the views. 
First we start with the app/views/devise/registrations/new.html.erb 
We want to remove the password_confirmation field, and add the input field for :name. 
Also we want that field to be autofocused instead of the :email field.
./app/views/devise/registrations/new.html.erb
<h2>Sign up</h2>

<%= simple_form_for(resource, as: resource_name, url: registration_path(resource_name)) do |f| %>
  <%= f.error_notification %>

  <div class="form-inputs">
    <%= f.input :name, required: true, autofocus: true %>
    <%= f.input :email, required: true %>

    <%= f.input :password, required: true, hint: ("#{@minimum_password_length} characters minimum" if @minimum_password_length) %>
  </div>

  <div class="form-actions">
    <%= f.button :submit, "Sign up" %>
  </div>
<% end %>

<%= render "devise/shared/links" %>

Basically the same goes for the ../registrations/edit.html.erb view,
Add the :name field, give it the autofocus. Remove the autofocus from the email field, and remove the password_confirmation field. 
./app/views/devise/registrations/edit.html.erb
<h2>Edit <%= resource_name.to_s.humanize %></h2>

<%= simple_form_for(resource, as: resource_name, url: registration_path(resource_name), html: { method: :put }) do |f| %>
  <%= f.error_notification %>

  <div class="form-inputs">
    <%= f.input :name, required: true, autofocus: true %>
    <%= f.input :email, required: true %>
    
    <% if devise_mapping.confirmable? && resource.pending_reconfirmation? %>
      <p>Currently waiting confirmation for: <%= resource.unconfirmed_email %></p>
    <% end %>

    <%= f.input :password, autocomplete: "off", hint: "leave it blank if you don't want to change it", required: false %>

    <%= f.input :current_password, hint: "we need your current password to confirm your changes", required: true %>
  </div>

  <div class="form-actions">
    <%= f.button :submit, "Update" %>
  </div>
<% end %>

<h3>Cancel my account</h3>

<p>Unhappy? <%= link_to "Cancel my account", registration_path(resource_name), data: { confirm: "Are you sure?" }, method: :delete %></p>

<%= link_to "Back", :back %>

Step 9
Before we continue and create our first user, let's save our work!
Doing a lot of small commits is actually considered as good practice, so save the work and commit it to Github.

git commit -m "Update user Registration and New views"

###########
19
ADDING FLASH MESSAGES
Before we try out our sign_up and edit form, we should add 'flash messages'. These kind of notifications are important to signal the user if an event was successful or failed, and maybe provide some kind of hint in case of a failure. 

Step 1
Bootstrap comes with great flash messages right out of the box, and it even has a nice javascript function to close the flash message. 
Let's use the standard Bootstrap flash-message and the by Rails provided Flash object.
Since these messages can occur throughout the entire application we'll add them to the application.hml.erb view, since that's the master view page. 
We'll use the bootstrap alert class, and give it the standard blue info color, and a nice fade-in. Also we add a button to dismiss the message. Since the standard flash object contains both the type and the message we'll have to specify them in the opening block, but we'll only use the message for this course. 
Place it right above the <%= yield %> statement, and right under the header. 

./app/views/layouts/application.html.erb
...
	<%= render 'layouts/header' %>
	
	<% flash.each do |type, message|  %>
		<div class="alert alert-info fade-in">
			<button class="close" data-dismiss="alert">x</button>
			<%= message %>
		</div>
	<% end %>

	<%= yield %>
...

Step 2
Now that we have the Application.html.erb view open, we should also add a container around the yield, so everything looks just a bit nicer. 

./app/views/layouts/application.html.erb
<!DOCTYPE html>
<html>
<head>
  <title>Stukplaces</title>
  <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track' => true %>
  <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %>
  <%= csrf_meta_tags %>
</head>
<body>
	
	<%= render 'layouts/header' %>

	<% flash.each do |type, message|  %>
		<div class="alert alert-info fade-in">
			<button class="close" data-dismiss="alert">x</button>
			<%= message %>
		</div>
	<% end %>

	<div class="container">
		<%= yield %>
	</div>

</body>
</html>

Step 3
And we should also update the login and logout links in our header, of course only showing the login and signup if there is not a current_user. 
Open your _header.html.erb partial, and add the links to login, logout, signin or signout.
Don't forget to remove the old links, and to add the method: :delete to the signout path.

./app/views/layouts/_header.html.erb

+
        <% if current_user %>
          <li><%= link_to 'Settings', edit_user_registration_path %> </li>          
          <li><%= link_to 'Logout', destroy_user_session_path, method: :delete %></li>
        <% else %>
          <li><%= link_to 'Login', new_user_session_path %></li>
          <li><%= link_to 'Signup', new_user_registration_path %></li>
        <% end %>

-
        <li><a href="#">login</a></li>
        <li><a href="#">signup</a></li>

You probably know how we got these routes, but it's always good to check your routes in the terminal to make sure.
rake routes

Step 4
As final, let's add a finishing touch to our flash messages by styling them. 
Open the app/assets/stylesheets/pages.scss file, and the following class to style it.
Give the .alert{} class the an absolute position, a z-index of 1, and a fixed width of 200px.

./app/assets/stylesheets/pages.scss

// Place all the styles related to the Pages controller here.
// They will automatically be included in application.css.
// You can use Sass (SCSS) here: http://sass-lang.com/
.alert{
	position: absolute;	
	z-index: 1; 
	width: 200px ; 
}

Step 5
If you didn't do so, this would be a great moment to restart your server, and head over to the localhost:3000/ to test our new layout, and the flash messages! 
Signup for your app, and be sure all your new links and flash messages work. 

Step 6
Time to save our work, and commit it to Github.

git commit -m "Add Flash messages"



###########
20
ADDING GRAVATARS

Step 1
Our users have no profile picture yet, and yet there is very simple way for each user to have a profile image. On the webs, they're called 'gravatar', and if you head over to www.gravatar.com you'll see exactly what I mean. 
There is even a gem for this, so let's add it to our Gemfile!
gem 'gravatarify', '~> 3.0.0'

And run bundle as usual
bundle

Step 2
Let's add the horizontal devider <hr> underneath the button in our app/views/devise/registrations/edit.html.erb form.  
And just below the <hr > we'll add the gravatar_tag helper that comes with the gem, and give the gravatar a size of 100 pix. 
Also add a link for the user to change the avatar, and point it to the gravatar website. 
<<EOF
  <div class="form-actions">
    <%= f.button :submit, "Update" %>
  </div>
  
  <hr>
  <%= gravatar_tag current_user.email, size: 100 %>
  <%= link_to 'change avatar', 'http://en.gravatar.com' %>

<% end %>

<h3>Cancel my account</h3>

<p>Unhappy? <%= link_to "Cancel my account", registration_path(resource_name), data: { confirm: "Are you sure?" }, method: :delete %></p>

<%= link_to "Back", :back %>

Step 3
Start up your server, and go to your user Settings Page to see your Profile image in action!

what if there is no image displayed?
If there is no image displayed, the user needs to sign up for gravatar.
Gravatars are widely used and most users will have them. 

Step 4
Looks good, save our work and commit it to Github.com

git commit -m "Added user Gravatar"

###########
21
GENERATING THE PLACES SCAFFOLD
Before we continue I'd like to point out that normally on intermediate or advanced courses we don't use any scaffolding. But for time-saving purposes we will scaffold the Places.

Step 1
So let's start with Scaffolding the Places.
We want the places to have:
    name:string
    address:string ( for later with the geocoder)
    description: text
    phone:string
    website:string
    user_id:string
And we'll be giving the extra flag to create the migration, without any stylesheets.

rails g scaffold Places name:string address:string description:text phone:string website:string user_id:integer --no-stylesheets
 

And after you have inspected the migration file, you can run the migration.

rake db:migrate

Step 2
Next we want to validate the presence of the Places fields, for the name, phone, address, website and user_id. Open the Places.rb model, and add the validations.

./app/models/places.rb

class Place < ActiveRecord::Base
	validates_presence_of :name 
	validates_presence_of :phone 
	validates_presence_of :address 
	validates_presence_of :website 
	validates_presence_of :user_id 
end

Step 3
We know that the places will be owned by a User, so we might as well continue with adding associations while we have the Places.rb model still open in our text editor.

./app/models/places.rb
class Place < ActiveRecord::Base
	validates_presence_of :name 
	validates_presence_of :phone 
	validates_presence_of :address 
	validates_presence_of :website 
	validates_presence_of :user_id 

	belongs_to :user
end

This also means we need to update the User.rb model, and say, that it has_many :places

./app/models/user.rb
class User < ActiveRecord::Base
  # Include default devise modules. Others available are:
  # :confirmable, :lockable, :timeoutable and :omniauthable
  devise :database_authenticatable, :registerable,
         :recoverable, :rememberable, :trackable, :validatable

   validates_presence_of :name      
   has_many :places
end

Step 4
When a user would visit our app now, there won't be a way to reach the places. 
Let's replace the current a:href stub in our _header.html.erb with a proper rails link_to 'places' link, and have it point to the places:index action, to show all the places. 

./app/views/layouts/_header.html.erb
...
      (<ul class="nav navbar-nav">)
-
        <li class="active"><a href="#">Places<span class="sr-only">(current)</span></a></li>
+
        <li><%= link_to 'Places', places_path %></li>
      (</ul>)
...

Step 5
If we now start the server, and go to our localhost:3000, we should have a working places link, and a Page showing all the listings.

This doesn't look very good if you ask me, so open the views/places/index.html.erb and let's make it look better. 
Let's start with removing elements we won't need to be shown on the index view. From the < table head> we remove the user, colspan, and description rows. And let's also remove them from the table body, including the :show :edit :delete actions, because these will be placed in a separate dashboard.

./app/views/places/index.html.erb

-
      <th>Description</th>

      <th>User</th>
      <th colspan="3"></th>

-
        <td><%= place.description %></td>

        <td><%= place.user_id %></td>
        <td><%= link_to 'Show', place %></td>
        <td><%= link_to 'Edit', edit_place_path(place) %></td>
        <td><%= link_to 'Destroy', place, method: :delete, data: { confirm: 'Are you sure?' } %></td>

Step 6
There is a paragraph tag in the top of the view for error notifications, since we now have flash messages we won't be needing this anymore. 
After you have removed the <p id="notice"><%= notice %></p> there are two more things left to do in this view.  
On the bottom, we have a line with a link to creating a new Place record. 
This should only be visible to logged-in users, so let's add these last two updates.      

./app/views/places/index.html.erb
-
<p id="notice"><%= notice %></p>

+
<% if current_user %> 
+
<% end %> 

And finally, add the bootstrap magic to the table, to make it an bootstrap table!

./app/views/places/index.html.erb
<<BOF
<h1>Listing Places</h1>
+
<table class="table">
...

Step 7
When we now start our server and go to the localhost:3000/places view, you'll notice that it looks a lot nicer!

Now some final, adjustments on the app/views/places/_form.html.erb partial to give the fields client side validations to, by stating required: true on those fields. 
./app/views/places/_form.html.erb
<%= simple_form_for(@place) do |f| %>
  <%= f.error_notification %>

  <div class="form-inputs">
+
    <%= f.input :name, required: true %>
    <%= f.input :address, required: true %>
    <%= f.input :phone, required: true %>
old (keep it!, but don't change it)
    <%= f.input :description %>
+
    <%= f.input :website, required: true %>
    <%= f.input :user_id, required: true %>
  </div>

  <div class="form-actions">
    <%= f.button :submit %>
  </div>
<% end %>

And with these updates our Places should look and work nice. Currently, we'll have to assign the :user_id manually, but we'll fix that in the upcoming lectures. 

Step 8
Let's save our work, and push it to Github.
git comit -m "Scaffold Users, and update the views"


###########
22
PLACES NEED A USER
Step 1
I Already mentioned it in the previous chapter, that we will change the way the :user_id is assigned to a place, so let's do that now.
Open the PlacesController.rb, and go to the bottom of the controller. 
Remove the :user_id from the place_params.
./app/controllers/places_controller.rb
<<EOF

    # Never trust parameters from the scary internet, only allow the white list through.
    def place_params
    -
      params.require(:place).permit(:name, :address, :phone, :description, :website, :user_id)
    +
      params.require(:place).permit(:name, :address, :phone, :description, :website )

    end
end

Step 2
Now in the create action, assign the @place variable to be constructed by calling current_user.places.new, like so:

./app/controllers/places_controller.rb

replace:
    @place = Place.new(place_params)
with:
    @place = current_user.places.new(place_params)

Step 3
And to make sure there is a current user, we'll use the :authenticate_user! method from devise, but only on the :new, :edit, :create, :update and :destroy actions.

./app/controllers/pages_conroller.rb
<<BOF
class PlacesController < ApplicationController
+  
  before_action :authenticate_user!, only: [:new, :edit, :create, :update, :destroy ]

Step 4
And finally, we can remove the :user_id field from the app/views/places/_form.html.erb
./app/views/places/_form.html.erb
<<BOF
<%= simple_form_for(@place) do |f| %>
  <%= f.error_notification %>

  <div class="form-inputs">
    <%= f.input :name, required: true %>
    <%= f.input :address, required: true %>
    <%= f.input :description %>
    <%= f.input :phone, required: true %>
    <%= f.input :website, required: true %>
-
    <%= f.input :user_id, required: true %>
  </div>

This should do the trick, restart the server if needed and go to your localhost:3000, and try to create a new place. 

Step 5
Save and commit our work to Github.

git commit -m "Added current user to places"



###########
23
PLACES NEED LOCATION
In this chapter, we'll be adding a map to our places, using google maps. 
For that, we will be needing an api key for google maps.
Maps need special coordinates in order to function, these you may have seen before, are called longitude and latitude.

Step 1
To convert an address to these longitude and latitude coordinates, we will be using a gem provided by alexreisner/geocoder .
When you're done reading the documentation you can add it to the gemfile, and run the bundle command.
https://github.com/alexreisner/geocoder

./Gemfile
<<EOF
gem 'geocoder'

install it
bundle

Step 2
Before we move on, we need to remove all the Places that are stored in the database at this moment. Open up a console, and run Place.delete_all

rails c 
Place.delete_all

Step 3
Next we need to add the latitude and longitude attributes to the Places. So, let's run a migration for this, and have them both be of the float type 

rails g migration AddMapToPlaces latitude:float longitude:float

And after inspection of the migration file, run migrate it to the database.

rake db:migrate

Step 4
Now, according to the documentation, we need to update the Places.rb model.
We need to tell geocoded from which field too 'decode', and to ensure the :geocoded address is validated. 

./app/models/place.rb
class Place < ActiveRecord::Base
	validates_presence_of :name 
	validates_presence_of :phone 
	validates_presence_of :address 
	validates_presence_of :website 
	validates_presence_of :user_id 

	belongs_to :user
+	
	geocoded_by :address 
	after_validation :geocode 
end

Step 5
To test if this works, we need to update our app/views/places/show view, and display the two new fields to the view. 
./app/views/places/show.html.erb
<<EOF
<p>
  <strong>User:</strong>
  <%= @place.user_id %>
</p>
+
    <p>
      <%= @place.longitude %>
      <%= @place.latitude %>
    </p>

<%= link_to 'Edit', edit_place_path(@place) %> |
<%= link_to 'Back', places_path %>

Now restart your server, and head over to your browser. Go to the localhost:3000/places/new, and create a new Place, with your City address.

Step 6
Now, before we can use these Coordinates in the Google Maps Api, we need to get an Api key from the google developers section.  Here is how you get it.
https://developers.google.com/maps/documentation/javascript/get-api-key

Press the [ GET A KEY ] button, and follow the procedure.

And as always,
store the API keys somewhere convenient, so that you can find them later on. 

Step 7
Now, if we follow the Google Developers Guide instructions (https://developers.google.com/maps/documentation/javascript/tutorial), we know that we have to add  our API key in the head section of our page, we can copy the code from the instructions and simply add our own key. 
On a production server you want to configure ENVironment key's, but for now this is just fine. Open your application.html.erb, and add the script snippet from the google documentation.
./app/views/layouts/application.html.erb
<<BOF
<!DOCTYPE html>
<html>
<head>
  <title>Stukplaces</title>
  <%= stylesheet_link_tag    'application', media: 'all', 'data-turbolinks-track' => true %>
  <%= javascript_include_tag 'application', 'data-turbolinks-track' => true %>
  <%= csrf_meta_tags %>
     <script async defer
      src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&callback=initMap">
    </script>
...

Make sure, you replace 'YOUR_API_KEY', with your API key.
Step 8
We also need to place the map somewhere, so in the app/views/places/show.html.erb, add a div with the id of 'map-canvas', as per the documentation. Also, specify a style, with the width and height for the map, like so:
./app/views/places/show.html.erb
<<EOF
+
<div id="map-canvas" style="width: 230px; height:230px"></div>

    <%= link_to 'Edit', edit_place_path(@place) %> |
    <%= link_to 'Back', places_path %>

Step 9
Next, we need to place the final part of the javascript, also on the bottom of the places:show page. 

./app/views/places/show.html.erb
<<EOF

<%= link_to 'Edit', edit_place_path(@place) %> |
<%= link_to 'Back', places_path %>
+
    <script type="text/javascript">
      var map;
      function initMap() {
        map = new google.maps.Map(document.getElementById('map-canvas'), {
          center: {lat: -34.397, lng: 150.644},
          zoom: 8
        });
      }
    </script>

Then, we add our coordinates.
./app/views/places/show.html.erb
<<EOF
<script type="text/javascript">
  var map;
  function initMap() {
    map = new google.maps.Map(document.getElementById('map-canvas'), {
    +
      center: {lat: <%= @place.latitude %>, lng: <%= @place.longitude %>},
      zoom: 8
    });
  }
</script>

And if we refresh the browser, you'll see a google map with the place you specified.

But the user has to guess where our address is right now, so let's go back to the documentation and look up how we can add a nice marker.

Step 10
In order to have a marker on our map, we need to remodel our maps script a little bit. 
First, we want to place the coordinates into a separate variable, and replace the center content with this new variable, inside the map object contstructor.

./app/views/places/show.html.erb
<script type="text/javascript">

  var map;
  var myCenter = {lat: <%= @place.latitude %>, lng: <%= @place.longitude %>};
  
  function initMap() {
    map = new google.maps.Map(document.getElementById('map-canvas'), {
      center: myCenter,
      zoom: 13
    });
  }
</script>

Then add the Marker object constructor, and give it the attributes it needs, the position and the map.

./app/views/places/show.html.erb
<script type="text/javascript">

  var map;
  var myCenter = {lat: <%= @place.latitude %>, lng: <%= @place.longitude %>};

  function initMap() {
    map = new google.maps.Map(document.getElementById('map-canvas'), {
      center: myCenter,
      zoom: 13
    });
    var marker = new google.maps.Marker({
      position: myCenter, 
      map: map, 
    });
  }
</script>

And after refreshing the browser (and sometimes restarting the server), we'll see a big fancy marker on our map. Awesome right?!

Step 11
Time to commit our work, and save it to Github!

git commit -m "Add Maps to Places"


###########
24
MAKING PLACES BETTER
Step 1
Before we move on with creating our reviews we should improve the design of our Places show pages, open the app/views/places/show.html.erb and remove the old content.
Just keep the <div >with the map-canvas, and the <script ...</script>, but remove everything else.
./app/views/places/show.html.erb

That includes removing the :edit and :back link, because we'll add them to the dashboard later on.

Step 2
We want our view to be divided into 2 main columns, the left side that will display the Place and its attributes, including the Map. And the second on the right will display the reviews and the review form that we have not created yet, but we can place a stub for now. 
So let's start with adding the bootstrap row, and add two columns, on with the size of 3, and the other with the size of 9, and place a <h3> tag inside each column, with either the Title for that section, or the place.name. 
./app/views/places/show.html.erb
<<BOF
+
 <div class="row">
  <div class="col-md-3">
    <h3><%= @place.name %></h3>
  </div>
  <div class="col-md-9">
    <h3>Reviews by People</h3>
    
  </div>
</div>
old code, don't touch
<div id="map-canvas" style="width: 230px; height:230px"></div>

Step 3
Let's continue by filling in the Place column with the Place attributes, add each attribute of the place inside of a <p> paragraph, and give it a <strong> Title, like so: 
./app/views/places/show.html.erb
<div class="row">
    
  <div class="col-md-3">
    <h3><%= @place.name %></h3>
    <p>
      <strong>Address</strong>
      <%= @place.name %>
    </p>
    <p>
      <strong>Phone</strong>
      <%= @place.phone %>
    </p>
    <p>
      <strong>Website</strong>
      <%= @place.website %>
    </p>
    <p>
      <strong>Description</strong>
      <%= @place.description %>
    </p>
  </div>

Step 4
And last, move the div with the map-canvas id to the bottom of the first column, right below the description paragraph.
./app/views/places/show.html.erb
      <strong>Description</strong>
      <%= @place.description %>
    </p>
    <div id="map-canvas" style="width: 230px; height:230px"></div>  
  </div>
  
Step 5
Check your browser, your show page should now look something like this.
Step 6
If you're happy with your progress, save your work, and Git commit!

git commit -m "Make places better"


###########
25
REVIEWS
Step 1
Every good place needs a solid review embedded in the view. We previously used scaffolds to generate the views, controllers and the Place model for us, but for the reviews, we'll create everything manually. 
The reviews will be shown inside of the places show view, so a review needs a place_id to know where it should be displayed. We also want a user to be assigned to the review, and of course a review should contain text. 
This leads us to create the following review Model

rails g model Review user_id:integer place_id:integer content:text

Inspect the generated migration file in the app/db/migrate folder before you run it.

rake db:migrate

Step 2
Continue by defining the associations,
Lets start with the User.rb model, a User has many reviews, and if the User would be removed, the reviews from that user should also be removed, so there would be no 'orphans' in our database. We actually forgot to do this on the places, so this would be a good time to add this dependent: :destroy to the places to.
./app/models/user.rb
<<EOF
   validates_presence_of :name      
   has_many :places, dependent: :destroy 
   has_many :reviews, dependent: :destroy
end

A place can have many reviews, again, we should make sure no orphans remain when the place is destroyed.
./app/models/places.rb
<<EOF
	belongs_to :user
	geocoded_by :address 
	after_validation :geocode 

	has_many :reviews, dependent: :destroy
end

And finally the Review.rb model, the review belongs to the user, and the place. 

./app/models/review.rb
class Review < ActiveRecord::Base
	belongs_to :user 
	belongs_to :place
end

Step 3
The Next task to do will be to create a controller, we could use the rails g controller command, but this would create a lot of files that we don't need. So let's create it by either the terminal command: touch app/controllers/reviews_controller.rb or by just using your mouse, and do a right click on the controller folder. 
./app/controllers/reviews_controller.rb
class ReviewsController <ApplicationController

end

Step 4
Here is pro-tip, although we didn't want to run the scaffold to create unnecessary files, we also won't want to repeat our selfs. Ruby/Rails programmers even have an idiom for this, called -DRY-,  "don't repeat yourself!" 
I like to peak at already existing example to see the structure, and maybe even copy code from one file to the other. 
If you want to copy-paste or manual retype everything is completely up to you, but I'll copy some code from the PlacesController into the ReviewsController, and simply edit it to be suited for the reviews. 
Here's how I do it, I open the two files next to each other in my Sublime

Then I will simply copy the actions from the Places controller that I would want to use in the Reviews Controller, these will be the :create, :update, and :destroy actions. 
 don't get confused by the @place references in the ReviewsController, we'll update that now
 
./app/controllers/reviews_controller.rb
class ReviewsController <ApplicationController
  

  def create
    @place = current_user.places.new(place_params)

    respond_to do |format|
      if @place.save
        format.html { redirect_to @place, notice: 'Place was successfully created.' }
        format.json { render :show, status: :created, location: @place }
      else
        format.html { render :new }
        format.json { render json: @place.errors, status: :unprocessable_entity }
      end
    end
  end

  def update
    respond_to do |format|
      if @place.update(place_params)
        format.html { redirect_to @place, notice: 'Place was successfully updated.' }
        format.json { render :show, status: :ok, location: @place }
      else
        format.html { render :edit }
        format.json { render json: @place.errors, status: :unprocessable_entity }
      end
    end
  end


  def destroy
    @place.destroy
    respond_to do |format|
      format.html { redirect_to places_url, notice: 'Place was successfully destroyed.' }
      format.json { head :no_content }
    end
  end


end

Of course, we now need to replace every @place with @review, all the place_params with review_params, and while we are editing, we should also remove all the format.json.lines, we won't use them in this recipe. 
./app/controllers/reviews_controller.rb
class ReviewsController <ApplicationController
  

  def create
    @review = current_user.reviews.new(review_params)

    respond_to do |format|
      if @review.save
        format.html { redirect_to @place, notice: 'Place was successfully created.' }
      else
        format.html { render :new }
      end
    end
  end

  def update
    respond_to do |format|
      if @review.update(review_params)
        format.html { redirect_to @place, notice: 'Place was successfully updated.' }
      else
        format.html { render :edit }
      end
    end
  end


  def destroy
    @review.destroy
    respond_to do |format|
      format.html { redirect_to places_url, notice: 'Place was successfully destroyed.' }
    end
  end


end

After this, your controller will look like this. The alert reader noticed that i didn't touch the redirect_to @place, that will be next. 
./app/controllers/reviews_controller.rb
class ReviewsController <ApplicationController
  

  def create
    @review = current_user.reviews.new(review_params)

    respond_to do |format|
      if @review.save
        format.html { redirect_to @place, notice: 'Place was successfully created.' }
      else
        format.html { render :new }
      end
    end
  end

  def update
    respond_to do |format|
      if @review.update(review_params)
        format.html { redirect_to @place, notice: 'Place was successfully updated.' }
      else
        format.html { render :edit }
      end
    end
  end


  def destroy
    @review.destroy
    respond_to do |format|
      format.html { redirect_to places_url, notice: 'Place was successfully destroyed.' }
    end
  end


end

Now let's update the redirects, so that on succes they will redirect_to the places_path and not the review_path, and update the notice: that will be given. 
./app/controllers/reviews_controller.rb

class ReviewsController <ApplicationController
  

  def create
    @review = current_user.reviews.new(review_params)

    respond_to do |format|
      if @review.save
        format.html { redirect_to place_path(@review.place) , notice: 'Review was successfully created.' }
      else
        format.html { render :new }
      end
    end
  end

  def update
    respond_to do |format|
      if @review.update(review_params)
        format.html { redirect_to place_path(@review.place), notice: 'Review was successfully updated.' }
      else
        format.html { render :edit }
      end
    end
  end


  def destroy
    @review.destroy
    respond_to do |format|
      format.html { redirect_to place_path(@review.place), notice: 'Review was successfully destroyed.' }
    end
  end


end

Step 5
And if we inspect the Places Controller a bit more, we see that we also need to create the private section, with the two methods for setting the review, and for defining the review params. 

./app/controllers/reviews_controller.rb
<<EOF
...
      format.html { redirect_to place_path(@review.place), notice: 'Review was successfully destroyed.' }
    end
  end

  private 

  def set_review
  	@review = Review.find(params[:id])	
  end

  def review_params
  	params.require(:review).permit(:content, :place_id)
  end
end

Then we create our hook for the set_review, to be set only on :edit, :update, and :destroy, and while we are adding hooks, we should also state that we need to have an authenticated user to perform actions on the reviews. 

./app/controllers/reviews_controller.rb
<<BOF
class ReviewsController <ApplicationController
	before_action :authenticate_user!
	before_action :set_review, only: [:edit, :update, :destroy]


  def create
  ...
  
This reminds me that I actually forgot to create the :edit action, add it right above the :create method. 
./app/controllers/reviews_controller.rb
<<BOF

class ReviewsController <ApplicationController
	before_action :authenticate_user!
	before_action :set_review, only: [:edit, :update, :destroy]

  def edit
  end

  def create

Step 6
Now it's time to create the views and form for the reviews. This means we have to create the app/views/reviews folder first. And in this folder, we want to create the _form.html.erb partial for our reviews.
Your folder structure, with the reviews folder, with the partial, will look like this:

./app/views/reviews/_form.html.erb

touch ./app/views/reviews/_form.html.erb
c9 ./app/views/reviews/_form.html.erb

Again we can copy the content from an existing form to our new form.
Let's copy the content from the places/_form.html.erb,  into our reviews/_form.html.erb
./app/views/reviews/_form.html.erb

<%= simple_form_for(@place) do |f| %>
  <%= f.error_notification %>

  <div class="form-inputs">
    <%= f.input :name, required: true %>
    <%= f.input :address, required: true %>
    <%= f.input :description %>
    <%= f.input :phone, required: true %>
    <%= f.input :website, required: true %>
  </div>

  <div class="form-actions">
    <%= f.button :submit %>
  </div>
<% end %>

And replace the attributes to represent the form for an @review, like so:
./app/views/reviews/_form.html.erb
<<BOF
<%= simple_form_for(@review) do |f| %>
  <%= f.error_notification %>

  <div class="form-inputs">
    <%= f.input :content, required: true %>
    <%= f.input :place_id, required: true %>
  </div>
  
Step 7
Let's render our review/_form in the places/show, by adding the render statement.
./app/views/places/show.html.erb
LN24:
<%= render 'reviews/form' %>

I think you'll know what kind of error we will get when we now would try to render our form. 
"NoMethodError in Places#show"

And probably you'll be able to predict the next error also, but for now, just follow along.
Let's first solve the first error, open the PagesController, and create the missing @review variable in the :show action.
./app/controllers/places_controller.rb
...
  def show
  + 
  @preview = Review.new
  
  end
...

And again, as you have probably guessed, we will get an error, but this time the error message says there is no path

So let's add the ROUTES for our reviews to solve this,

./app/config/routes.rb
<<BOF
Rails.application.routes.draw do
  resources :places
+
  resources :reviews

Step 8
Now, if all goes well, we can render the review form in our Places Show page.

As you notice, you see that we need to manually add the place id to our form. 
This should not be necessary, and we can easily fix this with the use of an hidden_field.

./app/views/reviews/_form.html.erb
<<BOF
<%= simple_form_for(@review) do |f| %>
  <%= f.error_notification %>

  <div class="form-inputs">
    <%= f.input :content, required: true %>
    <%= f.input :place_id, required: true %>
    <%= f.hidden_field :place_id, required: true, value: @place.id %>
  </div>

Step 9
And our last task for the reviews will be creating the _review partial, and render this in the Place Show page. 
In the app/views/reviews create the _review.html.erb partial.
We want to display the users gravatar, the review content, and the name from the reviewer, inside of a paragraph, so that it will be lined-out nicely. 
./app/views/reviews/_review.html.erb

Back to the app/views/places/show, add a smaller title from the h5 class, and render the @reviews
./app/views/places/show.html.erb
LN25-26 (+)
  <div class="col-md-9">
    <h3>Reviews by People</h3>
    <%= render 'reviews/form' %>
    <h5>All reviews</h5>
    <%= render @reviews %>
  </div>
</div>

And we need to tell our controller to render these reviews of course, so again back to the PlacesController, in the show action, add the @review variable, and set it to the be the reviews for t
./app/controllers/places_controller.rb
LN13-16
  def show
    @review = Review.new 
    @reviews = @place.reviews
  end

Back to the browser to see our new reviews working!

Step 10
Great success! Save our work, and commit it to Github.
git commit -m "Add reviews"


###########
26
SCORES

Step 1
Our reviews are working nice, so it's time to add some kind of rating to our application. I'd like to implement the well-known 'star rating' to our application. This way we can rate a place by giving stars, and we can easily see how many stars where given. 
There is a pretty awesome jQuerry Library that has everything we need. You can find the documentation on Github.
https://github.com/wbotelhos/raty
Go to the github page for raty, ...
https://github.com/wbotelhos/raty/blob/master/lib/jquery.raty.js

...and copy the contents of the /lib/jquery.raty.js into a new javascript file, in your app/assets/javascripts folder, and name it raty.js
./app/assets/javascripts/raty.js

Step 2
From the same github repo, find the /lib/images folder, and copy the 'star-on.png' and 'star-off.png' images to your assets/images folder. 

Step 3
Now we need to have a place to keep the score. Let's create a Migration to add the :score field to the Reviews model.

rails g migration AddScoreToReviews score:integer

But before running the migration, we should open it up and inspect it, but this time we'll add the default value of '0' to the field, so a review will always have a score. 

./app/db/migrate/.....add_score_to_reviews.rb
...
    add_column :reviews, :score, :integer, default: 0
...

Then migrate it to the database

rake db:migrate

Step 4
It would be a good idea to enforce some constraints on the Review.rb model, so that every time a review is created there will be content and a score. 

./app/models/review.rb
class Review < ActiveRecord::Base
	belongs_to :user 
	belongs_to :place

	validates_presence_of :content
	validates_presence_of :score 
end

We added a :score field to our Reviews, so we need to update the params in the reviews_controller as well, open it up, look for the review_params, and add the :score attribute to it. 

./app/controllers/reviews_controller.rb
<<EOF

  def review_params
  	params.require(:review).permit(:content, :place_id, :score)
  end
end

Step 5
Now it's time to add an input field to our review/_form, so right under the hidden_field in the review/_form partial, we will add a line for the :score. 
./app/views/reviews/_form.html.erb
...
    <%= f.hidden_field :place_id, required: true, value: @place.id %>
    <%= f.input :score, required: true %>
  </div>
...

After we restarted the server, our places view now has the :score field.  

Step 6
Now we are going to add the Raty script to our review/_form, This will be javascript, but very basic, so you won't have any trouble following along. 
Start with adding an empty div underneath the score field, and give it the class of 'score'. 
Next, open a script tag on the bottom of the form partial, and call the raty script on the '.score' div that we just created, and.
./app/views/reviews/_form.html.erb
<<EOF
<% end %>

<script>
  $(".score").raty({

  });
</script>

And now we will tell Raty the sources of our images, the target, to keep the target, and the target type.
Everything BUT the target you can find in the documentation, but to find your target, you have to open the browser inspector, and look for the ID of the :score input_field.


When you found the ID for the review_score, we can continue with filling in our Raty script with the sources, target, and target type, 
./app/views/reviews/_form.html.erb

<script>
  $(".score").raty({
    starOn: "<%= image_path('star-on.png') %>",
    starOff: "<%= image_path('star-off.png') %>",
    target: "#review_score",
    targetKeep: true, 
    targetType: "number"
  });
</script>

Go over to the browser, and see the score field now is dynamically populated by hovering or clicking on one of the stars. 

This means that we can now change the f.input :score into a hidden field as well because we don't have to display it to the user anymore. 

./app/views/reviews/_form.html.erb
<<BOF
<%= simple_form_for(@review) do |f| %>
  <%= f.error_notification %>

  <div class="form-inputs">
    <%= f.input :content, required: true %>
    <%= f.hidden_field :place_id, required: true, value: @place.id %>
    <%= f.hidden_field :score, required: true %>
    <div class="score"></div>

Step 7
We can now add ratings to our review by clicking on an image, let's continue by adding the same format of showing the :score with raty.js to our reviews.  
In order to do this, we need to do two things.
 First we need to define which #id raty should target because every rating is unique. 
And second, we need to create a new raty script that displays the score. 
Let's start with opening the app/views/reviews/_review partial, and create a div's to be populated by their unique score #ID
./app/views/reviews/_review.html.erb
    <div class="score_<%= review.id %>"></div>
    
Next, open the app/views/places/show view, and on the bottom, inside the javascript tags, we want to iterate over each review, and add the rating to the Raty score: field.  
You can copy the Raty script from the reviews/_form, and remove all unnecessary elements. Paste this inside the reviews iteration block. 
./app/views/places/show.html.erb
<<EOF
  }

  <% @reviews.each do |review| %>
      $(".score").raty({
      starOn: "<%= image_path('star-on.png') %>",
      starOff: "<%= image_path('star-off.png') %>",
      target: "#review_score",
      targetKeep: true, 
      targetType: "number"
    });
  <% end %>

</script>

And next we open the app/views/places/show, to add the script to populate these #ID's with the corresponding score. Start by copying over the script from the reviews/_form into the places/show view.
./app/views/places/show.html.erb

According to the documentation, we need to have two attributes, the score: and a statement that says that it should be read-only. 
And because we updated our _review partial to have a dynamic score_#id,  we need to embed this to the selector as well. 
./app/views/places/show.html.erb

  <% @reviews.each do |review| %>
      $(".score_<%= review.id %> ").raty({
      starOn: "<%= image_path('star-on.png') %>",
      starOff: "<%= image_path('star-off.png') %>",
      score: '<%= review.score %>',
      readOnly: true 
    });
  <% end %>

Back to the browser, refresh, and rate your new Score system with 5 stars as often as you can!

git commit -m "Add Raty for Rating"

###########
27
AVERAGE
Step 1
Our review system is working perfectly, it only needs one more thing, the average scoring..
For this, we need to create a few methods and a callback to invoke the method, but before that we need to create a Migration so that we can store the average rating. Let's add it to the Places Table, by creating a migration
rails g migration AddTotalAverageRatingToPlaces total_average:integer

As always, inspect the created migration file, but before running the migration, set the default total to be 0.
This way we are sure that every place has at least a -zero- review score, which will prevent errors later on. 

rake db:migrate

Step 2
Next we need a method to calculate the average for the place.
This method needs to be on the Place.rb model itself, and will simply fetch all the reviews from the place(self), sums them up, and then divides that by the number of reviews that there are.

./app/models/place.rb
<<EOF
	has_many :reviews, dependent: :destroy

	def average_rating
		self.reviews.sum(:score) / reviews.size 
	end
end

No rocket science here! 
But what if we would call this method on a Place that has -zero- reviews? 
We have set the default for the total_average to be 0, but the reviews can be any number of size.
You can try this out in the console, but the answer will be 'ZeroDivisionError', so we need a way handle this error. We'll add a rescue statement, to catch the ZeroDivissionError, and will set it to return 0.
	def average_rating
		self.reviews.sum(:score) / reviews.size 
	rescue ZeroDivisionError
		0
	end

Step 3
Now that we have a Method for calculating the average, we'll continue by creating the hook or callback that will call this method, and save it to database, everytime that a review is saved. 
First open the Review model, and place the after_save callback, and create the method.
./app/models/review.rb
<<EOF
	validates_presence_of :score 

	after_save :calculate_average

	def calculate_average
		
	end

end

Let's continue filling in this method.
First create a variable, and set it to the average_rating, next update the :total_average field for the place.
Your complete method will look like this. 
./app/models/review.rb
<<EOF
	def calculate_average
		a = self.place.average_rating
		self.place.update_attributes(total_average: a)
	end

end

now, restart your rails server, and create any number of reviews. Then close down the server, open up the rails console, and type:  Place.last.average_rating
rails c

Step 4
And last, we need a place to show the average rating of the place too. A good place would be right under the Place.name. In the app/views/places/show add another div that we can use for Raty, and give it the 'average' class. 

./app/views/places/show.html.erb
<<BOF
<div class="row">
  <div class="col-md-3">
    <h3><%= @place.name %></h3>
    <div class="average"></div>
    <p>
    
Now to add the javascript, and since this will be almost the same as the review, we can copy the previous code we used for the reviews, and simply change it to display the :total_average.

./app/views/places/show.html.erb
<<EOF
  <% end %>

  $(".score_<%= review.id %> ").raty({
    starOn: "<%= image_path('star-on.png') %>",
    starOff: "<%= image_path('star-off.png') %>",
    score: '<%= review.score %>',
    readOnly: true 
  });

</script>

Change the jQuery selector to get the new <div class="average".. and the set the score: to be @place.total_average
./app/views/places/show.html.erb
<<EOF
  $(".average ").raty({
    starOn: "<%= image_path('star-on.png') %>",
    starOff: "<%= image_path('star-off.png') %>",
    score: '<%= @place.total_average %>',
    readOnly: true 
  });

Start your rails server, open the browser and enjoy your fully functional rating system!

Step 5
Perfect moment to save our work, and commit it to github. 

git commit -m "Add the average rating"




###########
28
DASHBOARD
Step 1
Our application is shaping nicely but is also getting a bit complex to manage, so let's create a place for our user where he can manage his places and reviews. For this functionality, we want to create a dashboard. 
To do this we need to create a view, open up a route for the dashboard, and create an action. Let's start by adding the action to the Pages Controller, like so:
./app/controllers/pages_controller.erb
class PagesController < ApplicationController
  def home
  end

  def dashboard
  end
end

Step 2
Our dashboard will need some data, and the data is related to the user. In our dashboard we would want to show the user info, the places that the user created, and also the reviews from the user. Let's create the variables for that and give it the data we want. 
./app/controllers/pages_controller.rb

class PagesController < ApplicationController
  def home
  end

  def dashboard
  	@user = current_user
  	@places = @user.places 
  	@reviews = @user.reviews
  end
end

You noticed that we want our dashboard to display the data for the current user, as you know we can use the before_action with the devise provided :authenticate_user! method to make sure there is a current_user. 
We only want this for the dashboard, because the home action should be open for the public, and if there is a current_user, we should redirect them from the :home view to our :dashboard.
./app/controllers/pages_controller.rb
<<BOF
class PagesController < ApplicationController
	before_action :authenticate_user!, only: [:dashboard]

  def home
  	if current_user 
  		redirect_to dashboard_path
  	end
  end

Step 3
This means we now need to do tree things, the first is the route for the dashboard, and second it would be great to add the new dashboard_path to our header. Let's start with the route: 
./app/config/routes.rb
<<BOF
Rails.application.routes.draw do
  resources :places
  resources :reviews
  devise_for :users, controllers: { registrations: 'registrations'}
  root 'pages#home'
  get 'dashboard', to: 'pages#dashboard'

And add our new dashboard path in the app/views/layouts/_header, right before the settings link.
./app/views/layouts/_header.html.erb
LN27
      <ul class="nav navbar-nav navbar-right">
        <% if current_user %>
          <li><%= link_to 'Dashboard', dashboard_path %> </li>    

And the last will be creating the dashboard.html.erb view, in our app/views/layouts/pages folder. 

touch app/views/pages/dashboard.html.erb
c9 app/views/pages/dashboard.html.erb

./app/views/pages/dashboard.html.erb
Step 4
Now that everything is set up for our dashboard view to work, we can continue with filling it in.

For this we'll be using the bootstrap elements as usual, so let's start by adding a row to setup 3 columns.

The first to display the user info, the second for the places of the users, and the last for the reviews. Let's divide the standaard 12 column grid into 3 columns. For the profile we'll use 2 columns, and the places and reviews will have 5 columns each.

./app/views/pages/dashboard.html.erb
<div class="row">
	
	<!-- profile -->
	<div class="col-md-2">
	</div>

	<!-- places -->
	<div class="col-md-5">
	</div>

	<!-- reviews -->
	<div class="col-md-5">
	</div>

</div>

Let's start from the top, with the users profile. Give it a h3 tag with the user name, and place the users gravatar right under it. 
<div class="row">
	
	<!-- profile -->
	<div class="col-md-2">
	<h3><%= @user.name %>	</h3>
	<%= gravatar_tag @user.email, size: 150 %>
	</div>

Step 5
Let's continue with the second column, and add the places. We'll use the bootstrap table for this. 
Let's create 3 table rows inside the table head, with the title Name, and Created. Leave the third one blank. We'll put the edit and destroy actions there. 
./app/views/pages/dashboard.html.erb
	<!-- places -->
	<div class="col-md-5">
	<h3>My Places</h3>
	<table class="table">
	    <thead>
			<tr>
				<th>Name</th>
				<th>Created</th>
				<th> <!-- actions --> </th>
			</tr>
	    </thead>
	</table>

	</div>

And inside of the table body we will iterate over each place, and create a row for it with the proper attributes. 
./app/views/pages/dashboard.html.erb
		</thead>

		<tbody>
			<% @places.each do |place|  %>
				<tr>
					<td><%= place.name %></td>
					<td><%= time_ago_in_words(place.created_at) %> ago</td>
					<td><%= link_to "edit", edit_place_path(place) %> | <%= link_to "delete", place_path(place), method: :delete %></td>
				</tr>
				<% end %>
		</tbody>
	
	</table>
	
Step 6
One more column to go, the reviews. Again we want to use the bootstrap table, and we want to have the table place, date, and actions again in the table head, but let's also add the raty ratings again. 
Again, begin with <h3 > title, then the table like so:

./app/views/pages/dashboard.html.erb

	<!-- reviews -->
	<div class="col-md-5">
		<h3>My Reviews</h3>
		<table class="table">
			<thead>
				<tr>
					<th>Place</th>
					<th>When</th>
					<th>Rating</th>
					<th> <!-- actions --> </th>
				</tr>
			</thead>

		</table>
	</div>
	
And in the table body, we iterate over the @reviews, creating a table row for each review, and display the attributes. We had a very nice way to display the Raty ratings in our /reviews/show page, by assigning the score to the score_#id. Let's use that again for our dashboard.
./app/views/pages/dashboard.html.erb
					<th> <!-- actions --> </th>
				</tr>
			</thead>
			<tbody>
				<% @reviews.each do |review| %>
				  <tr>
					<td><%= review.place.name %></td>
					<td><%= time_ago_in_words(review.created_at) %> ago </td>
					<td class="score_<%= review.id %> "></td>
					<td><%= link_to "edit", edit_review_path(review) %> | <%= link_to "delete", review_path(review), method: :delete %></td>
				  </tr>
				<% end %>
			</tbody>
		</table>
	</div>

</div>

Now for the score_#id to be converted into the star rating, we need to copy the javacsript from our app/views/reviews/show to our dashboard. Don't forget to place them on the bottom of your view, inside the script tags. 
./app/views/pages/dashboard.html.erb
<<EOF
</div>

<script>
 <% @reviews.each do |review| %>
      $(".score_<%= review.id %> ").raty({
      starOn: "<%= image_path('star-on.png') %>",
      starOff: "<%= image_path('star-off.png') %>",
      score: '<%= review.score %>',
      readOnly: true 
    });
  <% end %>
</script>

git commit -m "Add the dashboard"

###########
29
BETTER LANDING PAGE
Step 1
Let's update our landing page now, because this really doesn't look very exciting for new visitors.

I think it would be nice to have a full width background on our home page.
I've found a great little code snippet that does exactly that! 
You can find it on css-tricks.com . 
https://css-tricks.com/perfect-full-page-background-image/
And I'll be using a nice blurred image as a background, just google for a nice background image to use, and place it in the assets directory.  I've learn a neat little trick to open the app directory so you don't have to go through all the folders, just type open . in the root of your folder, and your finder will open up the app folder.

And place your downloaded background image to the app/assets/images/ folder

Step 2
Next we want to update the views/pages/home view, start with deleting all the current content. 

./app/views/pages/home.html.erb
In our home view we want to have a nice big inviting button that says 'Find places you'll fall in love with', and that should be inside of div of course. Let's also give this div to more classes, one from bootstrap with 'text-center', and the other would be 'landing-title' which we will devine our selfs. 
./app/views/pages/home.html.erb
<div class="text-center landing_title">
	<%= link_to "Find places you'll fall in love with!", places_path, class: 'btn btn-default btn-lg' %>
</div>

Open the pages.scss, and specify the class of landing_title to have padding to the top of 200px.

./app/assets/stylesheets/places.scss
// Place all the styles related to the Pages controller here.
// They will automatically be included in application.css.
// You can use Sass (SCSS) here: http://sass-lang.com/
.alert{
	position: absolute;	
	z-index: 1; 
	width: 200px ; 
}

.landing_title{
	padding-top: 200px; 
}

Now we have nice button displayed roughly centered of our view. 
Step 3
Time to add the background snippit css-tricks.com, for this we need a div holding the content of the view. 
And here is the problem, if you remember from on of the previous steps, we already have a <div class="container"> surrounding the yield, so every view will be rendered inside this container, thus the image will always be rendered inside that container, and won't be the full width of the viewport. 
Let's do a simple 'if' statement to check if the current_page is the root_path, so that it won't render the <div class="container"> but a different div we specify for the landing page, eg <div class="landing">, like so:
./app/views/layouts/application.html.erb
<<EOF
			<%= message %>
		</div>
	<% end %>

	<% if current_page?(root_path) %>
		<div class="landing">
	<% else %>
		<div class="container">
	<% end %>
		<%= yield %>
	</div>

</body>
</html>

Now continue by adding the css snippet, add the background, set it to be no-repeat center center and give it a fixed position. Then specify to cover the background for all browsers, and set the height to be 100vh ;
And we also want to set the default margin for the navbar to be 0 at the bottom, so we won't have any empty space between the header and the div. 
./app/assets/stylesheets/pages.scss
<<EOF
.landing{
    background: image-url("blurred.jpg") no-repeat center center fixed ;
    -webkit-background-size: cover; 
    -moz-background-size: cover; 
    -o-background-size: cover;
    height: 100vh; 
}

.navbar{
	margin-bottom: 0; 
}

Step 4
I Think we can make the button a bit nicer too, let's remove the background, make the border a bit thicker, and change the border-color when we hover over it.
First add a extra class to our button on the home page, call it btn-landing . 
./app/views/pages/home.html.erb
<div class="text-center landing_title">
	<%= link_to "Find places you'll fall in love with!", places_path, class: 'btn btn-default btn-lg btn-landing' %>
</div>

Then update the css attributes for the button, remove the background, set the border, and add the hover state with a different border color.
./app/assets/stylesheets/pages.scss
.navbar{
	margin-bottom: 0; 
}

.btn-landing{
	background: none ; 
	border: solid ; 
	&:hover{
		border-color: green ;
	}
}

Let's go to the browser and see the result!

git commit -m "Improved landing page"



###########
30
SEARCH
Step 1
This will be very exciting step, because we will be adding search to our application. The search method will eventually perform a SQL query directly on the database, but first we need to update the current html search form and transform it to a nice rails search form.
Open the layouts/_header partial, and substitute the <form class=.. with a form_tag do-end block. 
Set the method to get, and copy give it the classes that the standard bootstrap form had.  
./app/views/layouts/_header.html.erb
-
      <form class="navbar-form navbar-left" role="search">
      <%= form_tag places_path, method: :get, class: 'navbar-form navbar-left' do %>
+

-
        <% end %>
      </form>
+

And we need to replace the input field with a rails text_field_tag, and direct the input to the params. Again we can copy the bootstrap classes from the old HTML input form.

./app/views/layouts/_header.html.erb
-
          <input type="text" class="form-control" placeholder="Search">
          <%= text_field_tag :search, params[:search], class: 'form-control', placeholder: "Type a Name or a Place" %>
+

Last, the button. Substitute the button with the rails submit_tag. Take note, that the search button needs an extra parameter to the name: attribute, to prevent it sending extra arguments. Again, we can re-use the provided bootstrap classes from the input button. 
./app/views/layouts/_header.html.erb
-
        <button type="submit" class="btn btn-default">Submit</button>
        <%= submit_tag "Search", name: nil, class: 'btn btn-default' %>
+

Step 2
Renew the browser, and try out the search form. There won't be any search results displayed yet, but you'll notice the search params in the URL.

We need to catch the search params in the controller, and show the listings that correspond. 
This means that we need to update the index action on the PlacesController, and tell it to show the Places that match the search params.  

./app/controllers/places_controller.rb
<<BOF
class PlacesController < ApplicationController
  before_action :authenticate_user!, only: [:new, :edit, :create, :update, :destroy ]
  before_action :set_place, only: [:show, :edit, :update, :destroy]

  # GET /places
  # GET /places.json
  def index
  +
    @places = Place.search(params[:search])
  end

This means we also need to create the search method on the places, we want to be able to search the 'name' field and the 'address' field, so the SQL query will look like this. 
./app/models/place.rb
<<EOF

	rescue ZeroDivisionError
		0
	end

	def self.search(search)
		if search 
			where(['name LIKE ? or address LIKE ?', "#{search}", "#{search}" ])
		else
			all
		end

	end

end

Step 3
And after we restart the server, and try out the search function with the exact name or address, you'll notice that our search functionality now works! 

Great work! The exact search match works. If you want to implement more advanced search functions you could check out something like elastic search, but for this recipe we'll stick to this. 

Step 4
Time so save, and commit our work to github. 

git commit -m "Add basic search"


###########
31
FINISHING TOUCHES

###########
32
DEPLOY


